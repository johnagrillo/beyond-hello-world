<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><h1>C++(C11,Clang)</h1><hr></hr><h2>ademoclass.cpp</h2><pre>#include "ademoclass.h"

ADemoClass::ADemoClass (std::string stringParam, std::string stringParamRw, int intParam, float floatParam):
  string_param_ stringParam),
  string_param_rw_ stringParamRw),
  int_param_ intParam),
  float_param_ floatParam)
{
  string_default_ = "string default";
  int_default_ = 0;
  float_default_ = 0.0;

}

ADemoClass::~ADemoClass ()
{

}










ostream &amp;
operator &lt;&lt; (ostream &amp; o, ADemoClass * aDemoClass)
{
  return o &lt;&lt; aDemoClass-&gt;string_param_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;string_default_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;string_param_rw_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;int_param_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;int_default_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;float_param_ &lt;&lt; "-"
           &lt;&lt; aDemoClass-&gt;float_default_ &lt;&lt; "-";
}

size_t 
ADemoClass::getHash()
{
  return this-&gt;stringParam.length() +
    this-&gt;stringDefault.length() +
    this-&gt;stringParamRw.length() +
    intParam +
    intDefault +
    floatParam +
    floatDefault;
}

bool 
ADemoClass::operator &lt;(ADemoClass &amp; aDemoClass) const
{
  if (string_param_ &lt; aDemoClass.string_param_) return true;
  if (string_param_ &gt; aDemoClass.string_param_) return false;
  //  string_param_ == aDemoClass.string_param_

  if (string_default_ &lt; aDemoClass.string_default_) return true;
  if (string_default_ &gt; aDemoClass.string_default_) return false;
  //  string_default_ == aDemoClass.string_default_

  if (string_param_rw_ &lt; aDemoClass.string_param_rw_) return true;
  if (string_param_rw_ &gt; aDemoClass.string_param_rw_) return false;
  //  string_param_rw_ == aDemoClass.string_param_rw_

  if (int_param_ &lt; aDemoClass.int_param_) return true;
  if (int_param_ &gt; aDemoClass.int_param_) return false;
  //  int_param_ == aDemoClass.int_param_

  if (int_default_ &lt; aDemoClass.int_default_) return true;
  if (int_default_ &gt; aDemoClass.int_default_) return false;
  //  int_default_ == aDemoClass.int_default_

  if (float_param_ &lt; aDemoClass.float_param_) return true;
  if (float_param_ &gt; aDemoClass.float_param_) return false;
  //  float_param_ == aDemoClass.float_param_

  if (float_default_ &lt; aDemoClass.float_default_) return true;
  if (float_default_ &gt; aDemoClass.float_default_) return false;
  //  float_default_ == aDemoClass.float_default_
  return false;

}

bool 
ADemoClass::operator &gt;(ADemoClass &amp; aDemoClass) const
{
  if ({to_member_s(m.name)} &lt; aDemoClass.string_param_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.string_param_) return true;
  //  {to_member_s(m.name)} == aDemoClass.string_param_

  if ({to_member_s(m.name)} &lt; aDemoClass.string_default_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.string_default_) return true;
  //  {to_member_s(m.name)} == aDemoClass.string_default_

  if ({to_member_s(m.name)} &lt; aDemoClass.string_param_rw_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.string_param_rw_) return true;
  //  {to_member_s(m.name)} == aDemoClass.string_param_rw_

  if ({to_member_s(m.name)} &lt; aDemoClass.int_param_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.int_param_) return true;
  //  {to_member_s(m.name)} == aDemoClass.int_param_

  if ({to_member_s(m.name)} &lt; aDemoClass.int_default_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.int_default_) return true;
  //  {to_member_s(m.name)} == aDemoClass.int_default_

  if ({to_member_s(m.name)} &lt; aDemoClass.float_param_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.float_param_) return true;
  //  {to_member_s(m.name)} == aDemoClass.float_param_

  if ({to_member_s(m.name)} &lt; aDemoClass.float_default_) return false;
  if ({to_member_s(m.name)} &gt; aDemoClass.float_default_) return true;
  //  {to_member_s(m.name)} == aDemoClass.float_default_
  return false;

}

bool 
ADemoClass::operator ==(ADemoClass &amp; aDemoClass) const
{
  return (string_param_ == aDemoClass.string_param_) &amp;&amp;
    (string_default_ == aDemoClass.string_default_) &amp;&amp;
    (string_param_rw_ == aDemoClass.string_param_rw_) &amp;&amp;
    (int_param_ == aDemoClass.int_param_) &amp;&amp;
    (int_default_ == aDemoClass.int_default_) &amp;&amp;
    (float_param_ == aDemoClass.float_param_) &amp;&amp;
    (float_default_ == aDemoClass.float_default_);
}

</pre><hr></hr><h2>ademoclass.h</h2><pre>#ifndef __ADEMOCLASS_H__
#define __ADEMOCLASS_H__
#include "pgutil.h"
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;assign.hpp&gt;
using namespace std;
using namespace boost;
using namespace boost::assign;
#include "factory.h"
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;shared_ptr.hpp&gt;

class ADemoClass {
public:
  ADemoClass (std::string stringParam, std::string stringParamRw, int intParam, float floatParam);

  ~ADemoClass ();


  std::string getStringParam(){return string_param_;}

  std::string getStringParamRw(){return string_param_rw_;}  ADemoClass &amp; setStringParamRw(std::string val) { string_param_rw_=val; return *this;}

  int getIntParam(){return int_param_;}

  float getFloatParam(){return float_param_;}


  friend ostream &amp; operator &lt;&lt; (ostream &amp; o, ADemoClass * aDemoClass);


  size_t getHash();
  bool operator &lt;(ADemoClass &amp; aDemoClass) const;
  bool operator &gt;(ADemoClass &amp; aDemoClass) const;
  bool operator ==(ADemoClass &amp; aDemoClass) const;

private:
  std::string stringParam;
  std::string stringDefault;
  std::string stringParamRw;
  int intParam;
  int intDefault;
  float floatParam;
  float floatDefault;

};


#endif /* __ADEMOCLASS_H_ */
</pre><hr></hr><h2>array03.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    vector &lt; vector &lt; vector &lt; int &gt; &gt; &gt; * array3= { { {0,1,2}, {10,11,12}, {20,21,22}}, { {100,101,102}, {110,111,112}, {120,121,122}}, { {200,201,202}, {210,211,212}, {220,221,222}}};

    std::cout &lt;&lt; array3 &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>array10.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    vector &lt; int &gt; * array= {1,2,3,4,5,6,7,8,9,10};

    std::cout &lt;&lt; array &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>array20.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    vector &lt; int &gt; * array= {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};

    std::cout &lt;&lt; array &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>hash10.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    map &lt; int,std::string &gt; * hashf={ {1,"string1"}, {2,"string2"}, {3,"string3"}, {4,"string4"}, {5,"string5"}, {6,"string6"}, {7,"string7"}, {8,"string8"}, {9,"string9"}, {10,"string10"}};

    std::cout &lt;&lt; hashf &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>integers.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;
    type  0=0;

    std::cout &lt;&lt; int_8_unsigned &lt;&lt; std::endl;
    std::cout &lt;&lt; int_16_unsigned &lt;&lt; std::endl;
    std::cout &lt;&lt; int_32_unsigned &lt;&lt; std::endl;
    std::cout &lt;&lt; int_64_unsigned &lt;&lt; std::endl;
    std::cout &lt;&lt; int_word_unsigned &lt;&lt; std::endl;
    std::cout &lt;&lt; int_8_signed &lt;&lt; std::endl;
    std::cout &lt;&lt; int_16_signed &lt;&lt; std::endl;
    std::cout &lt;&lt; int_32_signed &lt;&lt; std::endl;
    std::cout &lt;&lt; int_64_signed &lt;&lt; std::endl;
    std::cout &lt;&lt; int_word_signed &lt;&lt; std::endl;
    std::cout &lt;&lt; int_ap &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>nested.cpp</h2><pre>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;


int main(int argc, char * arg[])
{
    list &lt; list &lt; std::string &gt; &gt; * listOfListV= { {"1","2"}, {"3","4"}, {"5","6"}};
    list &lt; map &lt; std::string,std::string &gt;  &gt; * listOfHashV= {{ {"1","1"}, {"2","2"}},{ {"3","3"}, {"4","4"}},{ {"5","5"}, {"6","6"}}};
    list &lt; list &lt; map &lt; std::string,map &lt; std::string,std::string &gt;  &gt;  &gt; &gt; * mapListOfListOfHashOfHashV= { {{ {"hello1",{ {"hello2","hello4"}}}}}};

    std::cout &lt;&lt; listOfListV &lt;&lt; std::endl;
    std::cout &lt;&lt; listOfHashV &lt;&lt; std::endl;
    std::cout &lt;&lt; mapListOfListOfHashOfHashV &lt;&lt; std::endl;
    return 0;
}
</pre><hr></hr><h2>testademoclass.cpp</h2><pre></pre><hr></hr><h2>testademoclass.cpp.new</h2><pre></pre></html>
