<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Number Programs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
    </style>
</head>
<body>
    <h1>Random Number Programs in Various Languages</h1>

    <h2>
      If I could code a project in any language what language would I choose?
    </h2>
    
    <h2>
      <ol>
	<li>Generate 100 random numbers between 0 and 9</li>
	<li>Count the frequency of each number</li>
	<li>Calculate the combined total of each number multiplied by its frequency.</li>
      </ol>	
	
    </h2>
    
    <h2>
      I choose Python, Ruby, Java and C++
      <br>
      You can do this with c++ ranges as well.
      <br>      
      well almost!
      <br>
      There is no fold or reduce in std:ranges yet(was supposed to be in 23)
      <br>

      Modern languages have similar left to right streams and pipe lines.

      <br>
      The Ruby,Python,Java and C++ code was hand coded.
      <br>
      The remainder were generated by ChatGpt
      a
      
    </h2>

    <h3>
      <ul>
	<li> 100 random numbers - [3, 2, 3, 5, 9, 7, 7, 9, 1, 3, 0, 8, 1, 8, 4, 0, 9, 6, 6, 7, 6, 2, 8, 7, 1, 9, 0, 2, 1, 1, 0, 5, 0, 7, 6, 0, 9, 0, 5, 3, 2, 5, 0, 3, 3, 2, 4, 3, 5, 0, 2, 0, 4, 3, 7, 1, 0, 2, 9, 3, 6, 8, 1, 2, 2, 0, 1, 9, 6, 3, 6, 5, 0, 5, 3, 9, 7, 5, 0, 4, 7, 9, 7, 3, 6, 2, 8, 6, 3, 9, 9, 2, 2, 2, 4, 9, 5, 7, 2, 4]
	</li>
	
	<li>
	  frequencies - {7=>12, 4=>7, 1=>14, 8=>6, 0=>9, 5=>12, 2=>15, 3=>8, 6=>8, 9=>9}
	</li>
	
	<li>
	  key * value pairs = (7 *12) +  (4 *7) +  (1 *14) +  (8 *6) +  (0 *9) +  (5 *12) +  (2 *15) +  (3 *8) +  (6 *8) +  (9 *9) 
	  <br>
	  value  = 417
	</li>

	
      </ul>

    </h3>
    <h2>Ruby</h2>

      <pre><code>
out = 100.times.map{Random.rand(10)}.reduce(Hash.new{|h,k| h[k] = 0}) do |accum,val|
  accum.merge({val =>  accum[val]+1})
end.reduce(0) do |accum, (key,value)|
accum + key*value

	</code>
	</pre>




    <h2>Python</h2>
    <pre><code>
	import random
from collections import Counter
from functools import reduce

weighted_sum = reduce(lambda acc, item: acc + item[0] * item[1], Counter([random.randint(0, 9) for _ in range(100)]).items(), 0)

print(weighted_sum)

	</code>
	</pre>

    
      
    <h2>C++</h2>

      <pre><code>

int main()
{
	// Set up random number generation
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<int> dist(0, 9);

	auto values = std::views::iota(0, 100) | std::views::transform([&](int) { return dist(gen); });

	// Count frequencies using accumulate

	auto freq = std::accumulate(values.begin(),
		values.end(),
		std::unordered_map<int, int>{},
		[](std::unordered_map<int, int> accum, const int val) {
			accum[val]++;
			return accum; // Return the updated accumulator
		});

	// Reduce the values in the map (sum them up in this case)
	int sum = std::accumulate(
		freq.begin(), freq.end(), 0,
		[](int acc, const std::pair<int, int>& p) {
			return acc + p.first * p.second;  // accumulate only the values (p.second)
		});
	std::cout << sum << "\n";

	return 0;
}	  
    </code></pre>


    <h2>Java</h2>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        int weightedSum = new Random().ints(100, 0, 10) // Generate 100 random numbers
            .boxed()
            .collect(Collectors.groupingBy(n -> n, Collectors.counting()))
            .entrySet()
            .stream()
            .mapToLong(e -> e.getKey() * e.getValue())
            .sum();
        System.out.println("Weighted sum: " + weightedSum);
    }
}
    </code></pre>


      <hr>
      CHAT GPT
    <hr>
      
    <h2>Haskell</h2>
    <pre><code>
import System.Random (randomRIO)
import Data.List (group, sort)

main :: IO ()
main = do
    numbers <- replicateM 100 (randomRIO (0, 9))
    let weightedSum = sum [x * length g | g <- group (sort numbers), let x = head g]
    print weightedSum
    </code></pre>

    <h2>C#</h2>
    <pre><code>
using System;
using System.Collections.Generic;
using System.Linq;

class Program {
    static void Main() {
        var rand = new Random();
        var weightedSum = Enumerable.Range(0, 100)
            .Select(_ => rand.Next(0, 10))
            .GroupBy(n => n)
            .Select(g => g.Key * g.Count())
            .Sum();
        
        Console.WriteLine("Weighted sum: " + weightedSum);
    }
}
    </code></pre>

    <h2>D</h2>
    <pre><code>
import std.random : uniform;
import std.array : array;
import std.algorithm : sum, group;
import std.range : iota;
import std.stdio : writeln;

void main() {
    auto weightedSum = iota(100).map!(i => uniform(0, 10)).group!((a, b) => a == b).map!(g => g[0] * g.length).sum();
    writeln("Weighted sum: ", weightedSum);
}
    </code></pre>


    <h2>JavaScript</h2>
    <pre><code>
const weightedSum = Array.from({ length: 100 }, () => Math.floor(Math.random() * 10))
    .reduce((acc, val) => {
        acc[val] = (acc[val] || 0) + 1; // Count frequencies
        return acc;
    }, {})
    .entries()
    .reduce((sum, [key, count]) => sum + key * count, 0); // Compute weighted sum

console.log("Weighted sum:", weightedSum);
    </code></pre>

    <h2>OCaml</h2>
    <pre><code>
let random_numbers = Array.init 100 (fun _ -> Random.int 10)

let count_frequencies nums =
    let tbl = Hashtbl.create 10 in
    Array.iter (fun n -> Hashtbl.replace tbl n (1 + (try Hashtbl.find tbl n with Not_found -> 0))) nums;
    tbl

let weighted_sum tbl =
    Hashtbl.fold (fun key count acc -> acc + key * count) tbl 0

let () =
    Random.self_init ();
    let freqs = count_frequencies random_numbers in
    Printf.printf "Weighted sum: %d\n" (weighted_sum freqs)
    </code></pre>

    <h2>Rust</h2>
    <pre><code>
use rand::Rng; // Import the random number generator
use std::collections::HashMap;

fn main() {
    let mut rng = rand::thread_rng(); // Create a random number generator

    // Generate 100 random numbers between 0 and 9
    let weighted_sum: i32 = (0..100)
        .map(|_| rng.gen_range(0..10)) // Generate random numbers
        .fold(HashMap::new(), |mut acc, num| {
            *acc.entry(num).or_insert(0) += 1; // Count frequencies
            acc
        })
        .iter()
        .map(|(&key, &count)| key * count) // Multiply each number by its frequency
        .sum(); // Sum all the products

    println!("Weighted sum: {}", weighted_sum); // Output the weighted sum
}
    </code></pre>

    <h2>Clojure</h2>
    <pre><code>
(ns random-sum.core)

(defn random-number []
  (rand-int 10))

(defn weighted-sum []
  (let [numbers (repeatedly 100 random-number)
        frequencies (frequencies numbers)]
    (reduce + (map (fn [[k v]] (* k v)) frequencies))))

(println "Weighted sum:" (weighted-sum))`>
    </code></pre>

    <h2>Scala</h2>
    <pre><code>
import scala.util.Random

object Main extends App {
    val random = new Random
    val weightedSum = (0 until 100)
        .map(_ => random.nextInt(10)) // Generate 100 random numbers
        .groupBy(identity) // Count frequencies
        .map { case (num, counts) => num * counts.length } // Compute weighted sum
        .sum

    println(s"Weighted sum: $weightedSum") // Output the weighted sum
}
    </code></pre>

</body>
</html>
